<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mashplant.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="lalr1是一个用Rust编写，可以生成多种目标语言(目前实现了Rust, C++, Java)的parser generator。 在线演示网站：https:&#x2F;&#x2F;mashplant.online&#x2F;lalr1。不过其实演示的内容与lalr1的使用没有什么关系，只是用图形或者文字展示一下各种分析表，状态机，大概可以用来算编译原理的作业答案吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="lalr1使用指导">
<meta property="og:url" content="https://mashplant.github.io/lalr1-introduction/index.html">
<meta property="og:site_name" content="MashPlant的笔记">
<meta property="og:description" content="lalr1是一个用Rust编写，可以生成多种目标语言(目前实现了Rust, C++, Java)的parser generator。 在线演示网站：https:&#x2F;&#x2F;mashplant.online&#x2F;lalr1。不过其实演示的内容与lalr1的使用没有什么关系，只是用图形或者文字展示一下各种分析表，状态机，大概可以用来算编译原理的作业答案吧。">
<meta property="og:image" content="https://mashplant.github.io/pic/lalr1/dfa.png">
<meta property="og:image" content="https://mashplant.github.io/pic/lalr1/fsm.png">
<meta property="og:image" content="https://mashplant.github.io/pic/lalr1/conflict.png">
<meta property="og:image" content="https://mashplant.github.io/pic/lalr1/%E6%B5%8B%E8%AF%95.png">
<meta property="article:published_time" content="2020-08-17T08:38:05.000Z">
<meta property="article:modified_time" content="2020-09-14T03:05:32.209Z">
<meta property="article:author" content="MashPlant">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mashplant.github.io/pic/lalr1/dfa.png">

<link rel="canonical" href="https://mashplant.github.io/lalr1-introduction/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>lalr1使用指导 | MashPlant的笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="MashPlant的笔记" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MashPlant的笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">“你将孤单度过一生”</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mashplant.github.io/lalr1-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MashPlant">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MashPlant的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          lalr1使用指导
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-17 01:38:05" itemprop="dateCreated datePublished" datetime="2020-08-17T01:38:05-07:00">2020-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-13 20:05:32" itemprop="dateModified" datetime="2020-09-13T20:05:32-07:00">2020-09-13</time>
              </span>

          
            <span id="/lalr1-introduction/" class="post-meta-item leancloud_visitors" data-flag-title="lalr1使用指导" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/lalr1-introduction/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/lalr1-introduction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://github.com/MashPlant/lalr1" target="_blank" rel="noopener">lalr1</a>是一个用Rust编写，可以生成多种目标语言(目前实现了Rust, C++, Java)的parser generator。</p>
<p>在线演示网站：<a href="https://mashplant.online/lalr1" target="_blank" rel="noopener">https://mashplant.online/lalr1</a>。不过其实演示的内容与lalr1的使用没有什么关系，只是用图形或者文字展示一下各种分析表，状态机，大概可以用来算编译原理的作业答案吧。</p>
<a id="more"></a>

<p>lalr1的parser生成可以选择基于LALR1(1)文法或者LL(1)文法，鉴于我考虑到应该不会有人在可以使用LALR1(1)文法的情况下用LL(1)文法，这里不会介绍选择LL(1)文法时的用法。其实这个LL(1)文法的版本就不应该存在的，只是以前的decaf实验中有这么一个任务，我才做了这个支持，正常人怎么可能想用LL(1)文法呢。</p>
<p>lalr1生成parser的同时也生成了lexer，lexer内部的自动机是基于同样由我编写的<a href="https://github.com/MashPlant/re2dfa" target="_blank" rel="noopener">re2dfa</a>实现的。lalr1和re2dfa已经经受住了2019年的编译原理课的检验，不过这一套工具链毕竟不可能像flex，bison那样成熟，所以还是可能有一些不稳定因素，如果遇到了影响使用的bug，希望能够积极汇报。</p>
<p>lalr1有两套代码生成的方式，一种是利用Rust的过程宏，在Rust代码中嵌入产生式的信息，这一种显然只支持生成Rust代码；另一种是读取<a href="https://github.com/toml-lang/toml" target="_blank" rel="noopener">TOML</a>配置文件并输出代码，这一种支持上面说的三种语言。下面两节分别介绍这两种方式，你只需要阅读你选择的方式对应的一节，之后的两节”解决冲突”和”字符集”是general的，两种方法中都存在相关的概念。</p>
<h1 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h1><p>过程宏(<a href="https://doc.rust-lang.org/reference/procedural-macros.html" target="_blank" rel="noopener">Procedural Macros</a>)是Rust的一种语法特性。简单来说，过程宏的编写者定义了一个特殊的函数，它在Rust的编译过程中接受Rust的语法树，在执行任意的变换后返回一个新的语法树。这里不必完全了解过程宏的所有形式，只需要了解lalr1这个库中定义的过程宏怎么使用即可。下面这些小节会分别介绍一些使用上需要注意的点，如果觉得理解有困难，可以结合最后一小节”一个完整的例子”一起阅读。</p>
<p>在你希望成为一个parser的struct的impl块上添加<code>#[lalr1(Start)]</code>属性，其中<code>Start</code>是一个非终结符，是parser希望规约出来的最终结果。另外一个必要的属性是<code>#[lex = &quot;TOML of lexer&quot;]</code>，以TOML字符串的形式定义了词法分析器。此外还可以为impl块添加一些可选的属性，后面会详细描述。对于impl块中的每个函数，都使用Rust的正常函数的语法来编写语义动作，同时用函数级别的属性来描述产生式。</p>
<p>生成出来的Rust代码中不会保留这个impl块，也就是说这里面编写的东西都不会直接被编译。输出的结果包含两个enum，即<code>TokenKind</code>和<code>StackItem</code>，两个struct，即<code>Token</code>和<code>Lexer</code>，并为你希望成为parser的struct定义一个<code>parse</code>函数。根据我的使用经验，现在的IDE或者编辑器不太可能把这些符号识别出来并且给予正常的语法提示，如果希望了解具体的API的话，可以使用后面会提到的<code>#[expand]</code>，也可以使用<code>rust doc</code>，它会在展开过程宏后再分析API。</p>
<h2 id="编写lexer"><a href="#编写lexer" class="headerlink" title="编写lexer"></a>编写lexer</h2><p><code>#[lex = &quot;TOML of lexer&quot;]</code>的TOML字符串中应该包含<code>priority</code>和<code>lexical</code>两个字段，前者用于指定终结符的优先级和结合性，<strong>排在后面的优先级高</strong>(其实这与lexer没有任何关系，完全是parser的性质，不过在这里定义它比较方便)；后者用于指定终结符的正则表达式，<strong>排在前面的优先级高</strong>。</p>
<p>每次生成token时，lexer从剩余的字符串的开头查找一个最长的匹配。例如在下面的例子中，字符串<code>int1</code>中的<code>int</code>部分匹配<code>Int</code>的正则表达式，但是<code>int1</code>匹配<code>Id</code>的正则表达式，且更长，所以生成一个<code>Id</code> token；字符串<code>int</code>同时匹配<code>Int</code>和<code>Id</code>的正则表达式，但是<code>Int</code>排在前面，优先级更高，所以生成一个<code>Int</code> token。</p>
<p>一个简单的的例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[lex = r##<span class="meta-string">"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">priority = [</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  &#123; assoc = 'left', terms = ['Add'] &#125;,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  &#123; assoc = 'left', terms = ['Mul'] &#125;,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">]</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">[lexical]</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'int' = 'Int'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\+' = 'Add'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\*' = 'Mul'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\s+' = '_Eps'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\d+|(0x[0-9a-fA-F]+)' = 'IntLit' # Lit是Literal的缩写，整数字面值，就是整数常量的意思</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'[A-Za-z][_0-9A-Za-z]*' = 'Id'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'.' = '_Err'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"</span>##]</span></span><br></pre></td></tr></table></figure>

<p>这其中<code>Add</code>，<code>Mul</code>这些就是终结符的名字，在定义产生式的时候会用到，产生式中不支持直接用终结符的字符串形式来表示终结符，例如yacc/bison中可以写<code>Expr: Expr &#39;+&#39; Expr</code>，lalr1中是不行的，只能写成<code>Add</code>。</p>
<p>lexer中包含三个预定义的终结符：</p>
<ul>
<li><code>_Eps</code>：表示解析出这个结果时，lexer不应该告诉parser找到了一个终结符，而是忽略它继续解析下去。这个例子里遇到多个连续地空白字符时返回<code>_Eps</code>，parser就可以正确地忽略空白字符</li>
<li><code>_Err</code>：表示无法识别的输入，一般情况下lexer在遇到无法识别的输入时会返回一个<code>_Err</code> token，而且不会消耗输入字符串，也就是说之后无论调用它多少次都会返回<code>_Err</code> token。如果像这个例子一样，主动识别<code>.</code>，也就是遇到任意不符合上面的的模式的字符时返回<code>_Err</code>，那么输入字符串会被消耗(因为匹配了<code>.</code>)，下一次调用就会跳过这个字符</li>
<li><code>_Eof</code>：在字符串结束时自动生成一个提供给parser，告诉parser输入结束了</li>
</ul>
<p>生成出来的<code>Lexer</code>是可以独立于<code>Parser</code>使用的，下面的代码可以依次输出从一个字符串中解析出的全部token：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> lexer = Lexer::new(<span class="string">"your string here"</span>.as_bytes());</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> token = lexer.next();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, token);</span><br><span class="line">  <span class="keyword">if</span> token.kind == TokenKind::_Eof &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>re2dfa支持一个正则表达式的子集，这里列举几个不符合正则标准的地方</p>
<ol>
<li>不支持<code>{n}</code>，<code>{m,n}</code>，<code>^</code>，<code>$</code>，但是<code>{</code>，<code>}</code>，<code>^</code>，<code>$</code>仍然需要用<code>\</code>来转义，直接用会报错</li>
<li><code>()</code>没有分组作用(当然，因为这里根本没有分组这个概念)</li>
<li>只支持贪婪匹配</li>
<li>虽然支持<code>\s</code>，<code>\d</code>，<code>\w</code>，但不支持<code>\S</code>，<code>\D</code>，<code>\W</code></li>
<li><code>.</code>就是识别所有字符，而不是识别所有非换行符的字符</li>
<li><code>[]</code>内不支持多字节字符</li>
</ol>
<p>其余功能的支持也不一定完整，如果遇到了什么不符合直觉的结果可以把lexer单独拿出来调试一下，如果的确是re2dfa没有支持的话，就暂且换一个更简单的方法来实现吧，毕竟理论上正则只需要拼接，<code>|</code>和<code>*</code>就可以实现所有功能了。</p>
<p>有一些正则表达式虽然合法，也可以构造出正常的自动机，但是这些自动机可能不适合用于lexer。这样的正则表达式有两种，一种是不接受任何字符串，一种是接受空串。之所以说它们不适合用于lexer，是因为在遇到一些corner case的时候比较难以定义它们的行为，例如：</p>
<ul>
<li>如果输入是空字符串，不接受任何字符串的自动机应该返回<code>_Eof</code>还是<code>_Err</code>？</li>
<li>在字符串尾的时候，接受空串的自动机应该返回<code>_Eof</code>还是对应的token？</li>
</ul>
<p>出于这样的原因，lalr1(而不是re2dfa，因为从自动机的角度来说它们是完全合法的)禁止这样的正则表达式。</p>
<h2 id="impl块的可选属性"><a href="#impl块的可选属性" class="headerlink" title="impl块的可选属性"></a>impl块的可选属性</h2><p>除了<code>#[lalr1(Start)]</code>和<code>#[lex = &quot;TOML of lexer&quot;]</code>这两个必要的属性外，还可以添加几个额外的属性，目前支持的有以下几个：</p>
<ol>
<li><p><code>#[verbose = &quot;output path&quot;]</code></p>
<p>向指定路径输出一些用于调试的信息。</p>
<p>调试信息首先包括文法符号的编号及其对应的名字，产生式的编号及其对应的内容，剩余部分依据使用的文法而定。使用LALR(1)文法时为action表，出现冲突警告的时候可以利用这个文件来帮助查找语法中的问题。action表中包含每个节点包含的产生式及点的位置(不包含向前看符号)，以及每个节点处遇到终结符时的移进/规约/接受动作。每个动作都会在后面加上一个表示冲突情况的符号，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D;&gt; Shift(1) (✓)</span><br><span class="line">A &#x3D;&gt; Reduce(1) (-)</span><br><span class="line">B &#x3D;&gt; Shift(2) (✓)</span><br><span class="line">B &#x3D;&gt; Reduce(2) (✗)</span><br></pre></td></tr></table></figure>

<p>其中<code>(✓)</code>表示它最后被解析器采用，<code>(-)</code>表示它被利用优先级和结合性消除了，<code>(✗)</code>表示它被”强行”消除了，对应于一个冲突警告。详见后面的”解决冲突”一节。</p>
</li>
<li><p><code>#[log_token]</code></p>
<p>在生成的代码中，每当新解析出一个非<code>_Eps</code>的终结符时，输出它的相关信息，也就是输出一个struct <code>Token</code>，包括token类型，字符串片段，行号列号。</p>
</li>
<li><p><code>#[log_reduce]</code> </p>
<p>在生成的代码中，每当执行一次规约时，输出产生式。</p>
</li>
<li><p><code>#[use_unsafe]</code> </p>
<p>在生成的代码中使用一些<code>unsafe</code>来减少运行时检查，以期提高性能。例如将不可达断言转化成不可达hint，取消下标越界检查等。</p>
<p>理论上无论你编写的parser是什么样的，无论输入的字符串是是什么，只要成功生成代码并且成功编译了，这些<code>unsafe</code>都不会导致任何未定义行为(至少lalr1的目标是这个，至于是否真的达到了，目前暂且不能做出保证)。</p>
</li>
<li><p><code>#[expand]</code></p>
<p>输出生成的代码。之所以添加这个选项而不建议大家使用<code>cargo expand</code>来查看生成的代码，是因为后者把所有宏都展开了，不利于阅读或者调试，而且后者要求编译过程至少成功进行到了某个阶段(具体哪个阶段我还不清楚)才会输出，这对帮助解决编译错误可能是没有帮助的。</p>
<p>lalr1生成的Rust代码不包含位置信息，<strong>所以parser中的编译错误和运行错误都无法得知具体在什么位置</strong>，而如果使用<code>#[expand]</code>输出的代码来代替整个impl块，效果是完全等同的，这样可以方便调试或者看自己具体那里编译出错了。</p>
</li>
<li><p><code>#[show_fsm = &quot;output path&quot;]</code>和<code>#[show_dfa = &quot;output path&quot;]</code></p>
<p>分别把parser的lr fsm和lexer的dfa的图形以dot文件的形式输出到对应路径中。其实是没啥用的一个功能，对于稍微有一点意义的语法，这两个自动机都太大了，甚至dot文件都不一定能顺利地渲染成图片，更不用说靠人眼从中提取什么有用的信息了。</p>
</li>
</ol>
<h2 id="产生式和语法动作"><a href="#产生式和语法动作" class="headerlink" title="产生式和语法动作"></a>产生式和语法动作</h2><p>在impl块内部将产生式和语义动作结合起来，以函数的形式编写代码，一个例子如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[rule = <span class="meta-string">"Expr -&gt; LNot Expr"</span>]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">expr_lnot</span></span>(_: Token, e: Expr&lt;<span class="symbol">'p</span>&gt;) -&gt; Expr&lt;<span class="symbol">'p</span>&gt; &#123; Expr::Unary(LNot, <span class="built_in">Box</span>::new(e)) &#125;</span><br></pre></td></tr></table></figure>

<p>以下几点需要注意：</p>
<ol>
<li><strong>生命周期<code>&#39;p</code>是硬编码的</strong>，这意味着你把所有的<code>&#39;p</code>都换成<code>&#39;a</code>或者别的什么的，是不能work的。当然，理论上可以在过程宏中更加精细地提取代码中的这些信息，但是我想了一下，感觉收益明显小于付出，不多费事了</li>
<li>它虽然看起来是一个函数，但是其实<strong>不是</strong>，它的函数体会被提取出来当成代码段嵌在一个大函数中，<strong>所以不要在里面写return之类可以改变控制流的语句</strong></li>
<li>lalr1会对参数进行类型检查，保证一个非终结符只能对应于一个类型，保证终结符一定对应<code>Token</code>类型，但是这个检查完全是基于<strong>字符串比较</strong>的，并不会考虑任何Rust层面的语义信息(如类型别名)，所以是有可能把两个相同的类型判定为不相同的。编写类型也可能带来很多冗余，但是我认为这是有必要的，这是为了最大程度的保证生成器生成出来的代码能够通过rustc编译，避免后续产生不必要的编译错误</li>
</ol>
<p>函数上还可以添加一个属性：<code>#[prec = &quot;Term&quot;]</code>，这是指定这条产生式的优先级与终结符<code>Term</code>相同。具体作用的会在”解决冲突”一节描述。</p>
<h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><p>下面以<a href="https://github.com/MashPlant/lalr1/blob/master/tests/src/lalr1.rs" target="_blank" rel="noopener">一个解析四则运算表达式的parser</a>为例子讲解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span></span>; <span class="comment">// 用户希望成为parser的struct</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[lalr1(Expr)]</span></span><br><span class="line"><span class="meta">#[verbose = <span class="meta-string">"verbose.txt"</span>]</span></span><br><span class="line"><span class="meta">#[log_token]</span></span><br><span class="line"><span class="meta">#[log_reduce]</span></span><br><span class="line"><span class="meta">#[expand]</span></span><br><span class="line"><span class="meta">#[show_fsm = <span class="meta-string">"fsm.dot"</span>]</span></span><br><span class="line"><span class="meta">#[show_dfa = <span class="meta-string">"dfa.dot"</span>]</span></span><br><span class="line"><span class="meta">#[lex = r#<span class="meta-string">"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"># 描述终结符的优先级和结合性，越靠后优先级越高；结合性分为left，right和no_assoc</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">priority = [</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  &#123; assoc = 'left', terms = ['Add', 'Sub'] &#125;,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  &#123; assoc = 'left', terms = ['Mul', 'Div', 'Mod'] &#125;,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  &#123; assoc = 'no_assoc', terms = ['Neg'] &#125;, # Neg是一个"</span>虚假<span class="meta-string">"的终结符，lexer不会返回它，它只是用来帮助定义优先级</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  &#123; assoc = 'no_assoc', terms = ['RPar'] &#125;,</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">]</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"># 描述识别出终结符的正则表达式</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">[lexical]</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\(' = 'LPar'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\)' = 'RPar'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\+' = 'Add'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'-' = 'Sub'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\*' = 'Mul'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'/' = 'Div'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'%' = 'Mod'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\d+' = 'IntLit'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">'\s+' = '_Eps'</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"</span>#]</span></span><br><span class="line"><span class="keyword">impl</span> Parser &#123;</span><br><span class="line">  <span class="comment">// 任何一个非终结符的类型必须在整个parser中是统一的，例如这里的Expr是i32类型</span></span><br><span class="line">  <span class="comment">// 终结符必须是Token类型</span></span><br><span class="line">  <span class="comment">// 函数的名字其实是可以随便取的，最终的代码中并不会被保留，不过为了可读性还是最好符合本条规则的含义</span></span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; Expr Add Expr"</span>]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_add</span></span>(l: <span class="built_in">i32</span>, _op: Token, r: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; l + r &#125;</span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; Expr Sub Expr"</span>]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_sub</span></span>(l: <span class="built_in">i32</span>, _op: Token, r: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; l - r &#125;</span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; Expr Mul Expr"</span>]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_mul</span></span>(l: <span class="built_in">i32</span>, _op: Token, r: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; l * r &#125;</span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; Expr Div Expr"</span>]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_div</span></span>(l: <span class="built_in">i32</span>, _op: Token, r: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; l / r &#125;</span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; Expr Mod Expr"</span>]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_mod</span></span>(l: <span class="built_in">i32</span>, _op: Token, r: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; l % r &#125;</span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; Sub Expr"</span>]</span></span><br><span class="line">  <span class="meta">#[prec = <span class="meta-string">"Neg"</span>]</span> <span class="comment">// 本条产生式与Neg相同，比二元运算符都高</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_neg</span></span>(_op: Token, r: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; -r &#125;</span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; LPar Expr RPar"</span>]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_paren</span></span>(_l: Token, i: <span class="built_in">i32</span>, _r: Token) -&gt; <span class="built_in">i32</span> &#123; i &#125;</span><br><span class="line">  <span class="meta">#[rule = <span class="meta-string">"Expr -&gt; IntLit"</span>]</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">expr_int</span></span>(i: Token) -&gt; <span class="built_in">i32</span> &#123; std::<span class="built_in">str</span>::from_utf8(i.piece).unwrap().parse().unwrap() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跑一个实际的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(Parser.parse(&amp;<span class="keyword">mut</span> Lexer::new(<span class="string">b"1 - 2 * (3 + 4 * 5 / 6) + -7 * -9 % 10"</span>)), <span class="literal">Ok</span>(-<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p>结果显然是正确的。后面的内容其实就不影响使用了，可以跳过。</p>
<p>利用<code>#[expand]</code>，得到过程宏输出的代码如下(为了美观，代码经过了格式化)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个宏用来集中管理safe和unsafe模式下的下标访问和不可达</span></span><br><span class="line"><span class="comment">// 如果使用了use_unsafe的话，它们分别会调用get_unchecked和unreachable_unchecked</span></span><br><span class="line"><span class="built_in">macro_rules!</span> index &#123; ($arr: expr, $idx: expr) =&gt; &#123; &amp;$arr[$idx] &#125;; &#125;</span><br><span class="line"><span class="built_in">macro_rules!</span> impossible &#123; () =&gt; &#123; <span class="built_in">unreachable!</span>() &#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符的编号</span></span><br><span class="line"><span class="comment">// 终结符和非终结符都有编号，并且保证终结符的编号都小于非终结符的编号</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, Eq, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">TokenKind</span></span> &#123; _Eps, _Eof, _<span class="literal">Err</span>, Add, Sub, Mul, Div, Mod, Neg, RPar, LPar, IntLit &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lr分析的value stack的元素，这个例子里只能是lexer解析出来的token或者表示Expr的i32</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StackItem</span></span>&lt;<span class="symbol">'p</span>&gt; &#123; _Token(Token&lt;<span class="symbol">'p</span>&gt;), _0(<span class="built_in">i32</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lexer解析出来的token的类型，包含了终结符种类，对应的字符串片段，行列号信息</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, Eq, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Token</span></span>&lt;<span class="symbol">'l</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> kind: TokenKind,</span><br><span class="line">  <span class="keyword">pub</span> piece: &amp;<span class="symbol">'l</span> [<span class="built_in">u8</span>],</span><br><span class="line">  <span class="keyword">pub</span> line: <span class="built_in">u32</span>,</span><br><span class="line">  <span class="keyword">pub</span> col: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lexer</span></span>&lt;<span class="symbol">'l</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> string: &amp;<span class="symbol">'l</span> [<span class="built_in">u8</span>],</span><br><span class="line">  <span class="keyword">pub</span> line: <span class="built_in">u32</span>,</span><br><span class="line">  <span class="keyword">pub</span> col: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'l</span>&gt; Lexer&lt;<span class="symbol">'l</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(string: &amp;[<span class="built_in">u8</span>]) -&gt; Lexer &#123;</span><br><span class="line">    Lexer &#123; string, line: <span class="number">1</span>, col: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析产生一个Token</span></span><br><span class="line">  <span class="comment">// 如果解析结果是_Eps就不会返回给parser，如果是_Eof可能会导致parser完成最终的Acc或者出错</span></span><br><span class="line">  <span class="comment">// 如果是_Err会导致parser出错</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; Token&lt;<span class="symbol">'l</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ACC表示每个dfa节点对应于哪个终结符，如果一个都不对应就是_Err</span></span><br><span class="line">    <span class="keyword">static</span> ACC: [TokenKind; <span class="number">10</span>] = [一张巨大的表，这里不列了];</span><br><span class="line">    <span class="comment">// EC表示equivalent char，有些字符对dfa处理起来可能是一样的，用EC先减小字符集的大小，从而减小dfa转移表的大小</span></span><br><span class="line">    <span class="keyword">static</span> EC: [<span class="built_in">u8</span>; <span class="number">256</span>] = [一张巨大的表，这里不列了];</span><br><span class="line">    <span class="comment">// DFA_EDGE表示dfa的状态转移表，逻辑上DFA_EDGE[state][char]表示在state处遇到char时的下一个state编号</span></span><br><span class="line">    <span class="comment">// 规定编号0必须代表出错状态</span></span><br><span class="line">    <span class="comment">// 下面的所有u8(不包括上面那个EC的u8)，都是可以变化的，是可以容纳状态数的最小无符号整数</span></span><br><span class="line">    <span class="keyword">static</span> DFA_EDGE: [[<span class="built_in">u8</span>; <span class="number">10</span>]; <span class="number">10</span>] = [一张巨大的表，这里不列了];</span><br><span class="line">    <span class="comment">// line &amp; col是当前token的开始位置，self.line &amp; col是最后一个字符的位置</span></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> line, <span class="keyword">mut</span> col) = (<span class="keyword">self</span>.line, <span class="keyword">self</span>.col);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> last_acc = TokenKind::_<span class="literal">Err</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个循环不断把字符喂给dfa，直到：</span></span><br><span class="line">    <span class="comment">// 识别出一个非_Eps的token后出错或文件结尾 =&gt; 返回这个token</span></span><br><span class="line">    <span class="comment">// 没有识别出非_Eps的token时出错 =&gt; 返回_Err</span></span><br><span class="line">    <span class="comment">// 没有识别出非_Eps的token时文件结尾 =&gt; 返回_Eof</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="keyword">self</span>.string.len() &#123;</span><br><span class="line">      <span class="keyword">let</span> ch = *index!(<span class="keyword">self</span>.string, i);</span><br><span class="line">      <span class="keyword">let</span> ec = *index!(EC, ch <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">      <span class="keyword">let</span> nxt = *index!(index!(DFA_EDGE, state), ec <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">      <span class="keyword">let</span> acc = *index!(ACC, nxt <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">      <span class="keyword">if</span> acc != TokenKind::_<span class="literal">Err</span> &#123; last_acc = acc &#125;;</span><br><span class="line">      state = nxt <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">      <span class="keyword">if</span> nxt == <span class="number">0</span> &#123; <span class="comment">// 出错，不能消耗掉当前字符，它属于下一个token</span></span><br><span class="line">        <span class="keyword">let</span> piece = index!(<span class="keyword">self</span>.string, ..i);</span><br><span class="line">        <span class="keyword">self</span>.string = index!(<span class="keyword">self</span>.string, i..);</span><br><span class="line">        <span class="keyword">if</span> last_acc != TokenKind::_Eps &#123;</span><br><span class="line">          <span class="keyword">return</span> Token &#123; kind: last_acc, piece, line, col &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          line = <span class="keyword">self</span>.line;</span><br><span class="line">          col = <span class="keyword">self</span>.col;</span><br><span class="line">          last_acc = TokenKind::_<span class="literal">Err</span>;</span><br><span class="line">          state = <span class="number">0</span>;</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 维护行号列号</span></span><br><span class="line">        <span class="comment">// 有些字符其实宽度不一定是1(如tab)，但是简单起见这里统一用1表示了</span></span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">b'\n'</span> &#123;</span><br><span class="line">          <span class="keyword">self</span>.line += <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">self</span>.col = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">self</span>.col += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理文件结尾</span></span><br><span class="line">    <span class="keyword">let</span> piece = index!(<span class="keyword">self</span>.string, ..i);</span><br><span class="line">    <span class="keyword">self</span>.string = <span class="string">b""</span>;</span><br><span class="line">    <span class="keyword">if</span> last_acc != TokenKind::_Eps &amp;&amp; i != <span class="number">0</span> &#123; Token &#123; kind: last_acc, piece, line, col &#125; &#125; <span class="keyword">else</span> &#123; Token &#123; kind: TokenKind::_Eof, piece: <span class="string">b""</span>, line: <span class="keyword">self</span>.line, col: <span class="keyword">self</span>.col &#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lr分析中对于一个lookahead字符的几种动作</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, Eq, PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Act</span></span> &#123; Shift(<span class="built_in">u8</span>), Reduce(<span class="built_in">u8</span>), Acc, <span class="literal">Err</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'p</span>&gt; Parser &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">parse</span></span>&lt;<span class="symbol">'l</span>: <span class="symbol">'p</span>&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, lexer: &amp;<span class="keyword">mut</span> Lexer&lt;<span class="symbol">'l</span>&gt;) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, Token&lt;<span class="symbol">'l</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// PROD表示产生式的(左端项编号，右端项数目)</span></span><br><span class="line">    <span class="keyword">static</span> PROD: [(<span class="built_in">u8</span>, <span class="built_in">u8</span>); <span class="number">9</span>] = [一张巨大的表，这里不列了];</span><br><span class="line">    <span class="comment">// lr分析的动作表</span></span><br><span class="line">    <span class="keyword">static</span> ACTION: [[Act; <span class="number">12</span>]; <span class="number">18</span>] = [一张巨大的表，这里不列了];</span><br><span class="line">    <span class="comment">// lr分析的goto表</span></span><br><span class="line">    <span class="keyword">static</span> GOTO: [[<span class="built_in">Option</span>&lt;<span class="built_in">u8</span>&gt;; <span class="number">2</span>]; <span class="number">18</span>] = [一张巨大的表，这里不列了];</span><br><span class="line">    <span class="comment">// lr分析的state stack和value stack一起存放</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> stk: <span class="built_in">Vec</span>&lt;(_, <span class="built_in">u8</span>)&gt; = <span class="built_in">vec!</span>[(StackItem::_Token(Token &#123; kind: TokenKind::_Eps, piece: <span class="string">b""</span>, line: <span class="number">0</span>, col: <span class="number">0</span> &#125;), <span class="number">0</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> state = <span class="number">0</span>; <span class="comment">// state永远与栈顶相等，只是为了减少一些访存</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> token = lexer.next(); <span class="comment">// lookahead符号</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, token); <span class="comment">// log_token的作用，输出一个刚解析出的token</span></span><br><span class="line">    <span class="comment">// 标准的lr分析循环</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> act = *index!(index!(ACTION, state), token.kind <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">      <span class="keyword">match</span> act &#123;</span><br><span class="line">        Act::Shift(s) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 移进，把token压入value stack，把shift的目标状态压入state stack</span></span><br><span class="line">          stk.push((StackItem::_Token(token), s));</span><br><span class="line">          state = s <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">          <span class="comment">// 获取新的lookahead符号</span></span><br><span class="line">          token = lexer.next();</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, token); <span class="comment">// 还是log_token的作用，输出一个刚解析出的token</span></span><br><span class="line">        &#125;</span><br><span class="line">        Act::Reduce(r) =&gt; &#123;</span><br><span class="line">          <span class="comment">// 规约，从value stack上弹出对应数目的值，执行用户编写的语法动作</span></span><br><span class="line">          <span class="keyword">let</span> value = <span class="keyword">match</span> r &#123;</span><br><span class="line">            <span class="number">0</span> =&gt; &#123;</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">"Expr -&gt; Expr Add Expr"</span>); <span class="comment">// log_reduce的作用，输出产生式</span></span><br><span class="line">              <span class="keyword">let</span> r: <span class="built_in">i32</span> = <span class="keyword">match</span> stk.pop() &#123; <span class="literal">Some</span>((StackItem::_0(x), _)) =&gt; x, _ =&gt; impossible!() &#125;;</span><br><span class="line">              <span class="keyword">let</span> _op: Token = <span class="keyword">match</span> stk.pop() &#123; <span class="literal">Some</span>((StackItem::_Token(x), _)) =&gt; x, _ =&gt; impossible!() &#125;;</span><br><span class="line">              <span class="keyword">let</span> l: <span class="built_in">i32</span> = <span class="keyword">match</span> stk.pop() &#123; <span class="literal">Some</span>((StackItem::_0(x), _)) =&gt; x, _ =&gt; impossible!() &#125;;</span><br><span class="line">              <span class="comment">// 这个 l + r 就是用户编写的语法动作，嵌到这里来了</span></span><br><span class="line">              StackItem::_0(&#123; &#123; l + r &#125; &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里省略类似的Sub Mul Div Mod...</span></span><br><span class="line">            <span class="comment">// 最后的一次规约，把用户定义的目标非终结符规约到增广语法中新定义的非终结符</span></span><br><span class="line">            <span class="number">8</span> =&gt; &#123;</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">"_ -&gt; Expr"</span>);</span><br><span class="line">              <span class="keyword">let</span> _1 = <span class="keyword">match</span> stk.pop() &#123; <span class="literal">Some</span>((StackItem::_0(x), _)) =&gt; x, _ =&gt; impossible!() &#125;;</span><br><span class="line">              StackItem::_0(&#123; _1 &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _ =&gt; impossible!(),</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="comment">// 在value stack上压入新生成的value，并且通过访问goto表得知state stack上需要压入的新state</span></span><br><span class="line">          <span class="keyword">let</span> nxt = *index!(index!(GOTO, index!(stk, stk.len() - <span class="number">1</span>).<span class="number">1</span> <span class="keyword">as</span> <span class="built_in">usize</span>), *index!(PROD, r <span class="keyword">as</span> <span class="built_in">usize</span>) <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">          stk.push((value, nxt));</span><br><span class="line">          state = nxt <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接受，将栈顶作为最终结果返回</span></span><br><span class="line">        Act::Acc =&gt; <span class="keyword">return</span> <span class="literal">Ok</span>(<span class="keyword">match</span> stk.pop() &#123; <span class="literal">Some</span>((StackItem::_0(r), _)) =&gt; r, _ =&gt; impossible!() &#125;),</span><br><span class="line">        <span class="comment">// 出错，返回导致出错的token</span></span><br><span class="line">        Act::<span class="literal">Err</span> =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(token),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFA的图形是这样的：</p>
<p><img src="/pic/lalr1/dfa.png" alt="dfa"></p>
<p>再看一个巨大的LR(1) FSM(美观起见，我把<code>Add</code>等终结符换成了对应的符号，<code>_Eof</code>替换成了<code>#</code>)：</p>
<p><img src="/pic/lalr1/fsm.png" alt="fsm"></p>
<p>值得注意的是这个LR(1) FSM是没有经过解决冲突的处理的，例如图中的这一处：</p>
<p><img src="/pic/lalr1/conflict.png" alt="conflict"></p>
<p>显然是有移进-规约冲突的。文本表示的verbose信息中体现了冲突的解决，这个片段对应于<code>verbose.txt</code>中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">State 13:</span><br><span class="line">  Expr -&gt; Expr.Add Expr</span><br><span class="line">  Expr -&gt; Expr Add Expr.</span><br><span class="line">  Expr -&gt; Expr.Sub Expr</span><br><span class="line">  Expr -&gt; Expr.Mul Expr</span><br><span class="line">  Expr -&gt; Expr.Div Expr</span><br><span class="line">  Expr -&gt; Expr.Mod Expr</span><br><span class="line"></span><br><span class="line">  Mul &#x3D;&gt; Shift(9) (✓) # 遇到*时移进，因为*优先级比+高</span><br><span class="line">  Mul &#x3D;&gt; Reduce(0) (-)</span><br><span class="line">  RPar &#x3D;&gt; Reduce(0) (✓)</span><br><span class="line">  Div &#x3D;&gt; Shift(10) (✓) # 遇到&#x2F;时移进，因为&#x2F;优先级比+高</span><br><span class="line">  Div &#x3D;&gt; Reduce(0) (-)</span><br><span class="line">  Add &#x3D;&gt; Shift(7) (-)</span><br><span class="line">  Add &#x3D;&gt; Reduce(0) (✓) # 遇到+时规约，因为+左结合</span><br><span class="line">  Mod &#x3D;&gt; Shift(11) (✓) # 遇到%时移进，因为%优先级比+高</span><br><span class="line">  Mod &#x3D;&gt; Reduce(0) (-)</span><br><span class="line">  Sub &#x3D;&gt; Shift(8) (-)</span><br><span class="line">  Sub &#x3D;&gt; Reduce(0) (✓) # 遇到-时规约，因为+和-优先级一样高，而+左结合</span><br><span class="line">  _Eof &#x3D;&gt; Reduce(0) (✓)</span><br></pre></td></tr></table></figure>

<p>可见这里所有冲突选择都被优先级和结合性的约束给消除了。</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><blockquote>
<p>如果你选择使用过程宏来生成代码，那么这一节可以完全跳过。</p>
</blockquote>
<p>首先通过如下指令安装<code>parser_gen</code>，这个二进制程序就是负责读入TOML文件，输出指定的目标语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https:&#x2F;&#x2F;github.com&#x2F;MashPlant&#x2F;lalr1 --features&#x3D;&quot;clap toml&quot;</span><br></pre></td></tr></table></figure>

<p>直接运行这个程序就可以得到帮助信息，因此这里不再介绍怎么使用它。</p>
<p>输入的TOML文件中可以包含如下字段(可以参照<a href="https://github.com/MashPlant/lalr1/tree/master/parser-gen/examples" target="_blank" rel="noopener">https://github.com/MashPlant/lalr1/tree/master/parser-gen/examples</a>文件夹下三个目标语言的TOML文件一起阅读)：</p>
<ul>
<li><code>include</code>：字符串，会被添加到输出的文件的开头位置</li>
<li><code>priority</code>：与过程宏中”编写lexer”一节的<code>priority</code>格式完全相同</li>
<li><code>lexical</code>：与过程宏中”编写lexer”一节的<code>lexical</code>格式完全相同</li>
<li><code>parser_field</code>：字符串列表，每个字符串表示parser结构体的一个字段</li>
<li><code>start</code>：字符串，表示初始非终结符</li>
<li><code>production</code>：列表，每个元素表示一组左端项相同的产生式，用一个TOML中的map表示，结构如下：<ul>
<li><code>lhs</code>：字符串，左端项的名字</li>
<li><code>ty</code>：字符串，左端项的类型</li>
<li><code>rhs</code>：列表，表示一组产生式，每个产生式也用一个map表示，结构如下：<ul>
<li><code>rhs</code>：字符串列表，每个字符串是产生式右端的一项</li>
<li><code>rhs_arg</code>：可选的列表，每个元素是一个长度为2的字符串列表，分别表示一个右端项在语法动作中的名字和类型。如果存在的话它会被用于类型检查，不存在的话这个检查就跳过了，生成的代码交给目标语言的编译器去检查。一般来说在TOML文件中描述这些类型信息太麻烦了，所以这个功能一般只用于过程宏模式下，这里直接不写这个字段就行了</li>
<li><code>act</code>：字符串，是目标语言的一段代码，表示语法动作。这里可以使用产生式的右端项，如果没有在<code>rhs_arg</code>中为它们起名字的话，Rust和C++中用<code>_1</code>，<code>_2</code>…等表示它们，Java中用<code>$1</code>，<code>$2</code>…等表示它们。Rust代码中这个语法动作最终应该是一个值(语句块的最后一个表达式如果没有分号的话就是整个语句块的值)，C++代码中最终应该把结果赋值给<code>__</code>，Java代码中最终应该把结果赋值给<code>$.$</code>。这一段代码不是放在一个独立的函数里面的，而是都嵌在一个大函数里面，所以不要在这里写return之类可以改变控制流的语句</li>
<li><code>prec</code>：可选的字符串，如果存在，表示一个终结符，本条产生式的优先级与这个终结符相同，详细功能见”解决冲突”一节</li>
</ul>
</li>
</ul>
</li>
<li><code>parser_def</code>：可选的字符串，如果不存在，就会定义一个名称为<code>Parser</code>的结构体，并为它定义<code>parse</code>函数；如果存在，就会直接为名称为它的结构体定义<code>parse</code>函数。目标语言为Java时这个字段会被忽略，总是会定义一个名为<code>Parser</code>的类。</li>
</ul>
<p>生成的代码的基本功能和实现方式基本上都和基于过程宏的版本是一样的，所以没有必要重复介绍了。</p>
<h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>我找了很多文档，也用yacc/bison做了很多实验，但仍然没有总结出一个完整的解决和汇报冲突的策略。既然这样，那我就不尝试实现它的规范了，lalr1以我的规范为准，如果和yacc/bison的表现不一致，那就不一致吧。(当然，如果它的表现和我声明的规范矛盾了，那肯定还是一个bug)</p>
<p>首先定义产生式的优先级(不定义产生式的结合性，因为没有意义且不会用到)。没有<code>#[prec(Term)]</code>时，产生式的优先级与右端最后一个终结符的优先级相同，如果右端没有终结符或者右端最后一个终结符没有定义优先级，那么这条产生式就没有优先级；有<code>#[prec(Term)]</code>时，产生式的优先级与与终结符<code>Term</code>相同，同样如果<code>Term</code>没有优先级，那么这条产生式就没有优先级。</p>
<p>先假设只有两种冲突选择：</p>
<ul>
<li>若为规约-规约冲突<ul>
<li>如果两个规约选择都有优先级，且优先级不相等，则选择优先级高的产生式规约</li>
<li>否则，选择先出现的产生式规约，且汇报一个冲突警告</li>
</ul>
</li>
<li>若为移进-规约冲突<ul>
<li>若待移进的终结符和待规约的产生式都有优先级(注意此时待移进的终结符一定也有结合性)<ul>
<li>若待移进的终结符优先级高，则移进</li>
<li>若待规约的产生式优先级高，则规约</li>
<li>若二者优先级相等<ul>
<li>若移进的终结符为左结合，则规约</li>
<li>若移进的终结符为右结合，则移进</li>
<li>若移进的终结符为不结合(有结合性，结合性是不结合)，则既不移进也不规约，这两种选择都不合法</li>
</ul>
</li>
</ul>
</li>
<li>否则，移进，并且汇报一个冲突警告</li>
</ul>
</li>
</ul>
<p>以上就是解决冲突的全部内容了吗?这的确是文档里能找到的全部内容了，但我认为事情还没说完：在一个状态转移上，可行的选择可能大于两个。这一定是有大于两个规约选择，或者有一个移进选择和大于一个规约选择。</p>
<p>这之所以会成为一个问题，是因为没办法通过直接推广上面的两两比较来选择出一个”最好”的选择。在集合{ 移进，规约1，规约2，…，规约n }上如果定义x ≤ y ⇔ x和y冲突的时候选y，那么这个关系并不是一个合法的偏序关系，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">规约x：无优先级，出现在第2位</span><br><span class="line">规约y：优先级1，出现在第1位</span><br><span class="line">规约z：优先级2，出现在第3位</span><br></pre></td></tr></table></figure>

<p>那么满足x ≤ y和y ≤ z，但是不满足x ≤ z。</p>
<p>即使先不考虑所有的需要”汇报一个冲突警告”的情形，也就是说产生式的优先级和终结符的优先级和结合性都存在且产生式的优先级不会相等，这时这个关系的确是一个偏序关系。然而如果需要处理结合性为不结合的终结符，仍然不能做出非常令人信服的选择(因为这个偏序集仍然不是全序的)，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">规约x： 优先级1</span><br><span class="line">规约y： 优先级2</span><br><span class="line">移进z： 优先级2，结合性为不结合</span><br></pre></td></tr></table></figure>

<p>有两种理解是合理的：一是规约y和移进z”抵消”了，所以选择规约x；二是规约x因为优先级不如规约y而不能选择，规约y和规约z因为终结符不结合也不能选择，所以没有选择。</p>
<p>我没有查到yacc/bison是怎么处理这些情况的，试图通过实验来归纳的时候也遇到了很多无法理解的问题，没有得出有用的结论。简单起见，规定如果有大于两个冲突选择，<strong>lalr1将拒绝生成代码</strong>。它会把冲突情况做出一定程度的汇报，然后失败退出。</p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>上面一直在提”字符”的概念，这其实是一个非常模糊的表述，为了严谨起见有必要说明清楚。不过实际上我相信实际用lalr1编写的parser基本都是用来识别纯ASCII码的源程序的，所以应该是不会遇到字符编码相关的问题的。</p>
<p>re2dfa是<strong>完全基于字节</strong>的，也就是说从输入的正则表达式，到内部的处理过程，到最终生成的自动机，都假定了处理的字符集一定是在<code>0, 1, ..., 255</code>这个范围内的。最终生成的自动机对各种编码完全没有感知，只是逐字节读入数据并执行状态转移。所有的目标语言都是这样的：Rust中逐个<code>u8</code>地读入，C++中逐个<code>char</code>地读入，Java中逐个<code>byte</code>地读入。</p>
<p>不过这并不意味着生成的lexer只能识别单字节字符组成的字符串，因为即使输入的正则表达式中包含了需要多个匹配字节才能识别的字符，这对自动机来说无非就是多执行几次状态转移而已，并没有什么困难的(当然也有困难的情形，如前面所说<code>[]</code>内不支持多字节字符，就是因为如果要实现的话会增加不少复杂性，考虑<code>[^a]</code>和<code>[a-b]</code>的情况，其中<code>a</code>和<code>b</code>是多字节字符)。例如一个UTF-8编码的正则<code>(测试)*</code>的自动机如下：</p>
<p><img src="/pic/lalr1/%E6%B5%8B%E8%AF%95.png" alt="测试"></p>
<p>这其中的<code>230 181 139 232 175 149</code>就对应于<code>测试</code>的每个字节。</p>
<p>在现在这样的实现下，可以很容易地精确描述出正则中的一些特殊字符的具体含义：</p>
<ul>
<li><code>.</code>：等价于<code>[\x00-\xFF]</code>(大家可能不熟悉<code>\xHH</code>的写法，这是一个值为16进制数<code>HH</code>的字节)</li>
<li><code>\s</code>：等价于<code>[\n\t\r ]</code></li>
<li><code>\d</code>：等价于<code>[0-9]</code></li>
<li><code>\w</code>：等价于<code>[0-9a-zA-Z_]</code></li>
</ul>
<p>虽然这看起来没什么特别的，但是在对字符编码有感知的正则表达式实现中并不是这样的，例如Rust的正则库<a href="https://docs.rs/regex/1.3.9/regex/" target="_blank" rel="noopener">regex</a>的规范中规定：</p>
<blockquote>
<p><code>\w</code>, <code>\d</code> and <code>\s</code> are Unicode aware. For example, <code>\s</code> will match all forms of whitespace categorized by Unicode.</p>
</blockquote>
<p>举例来说，它的<code>\s</code>可以匹配中文全角空格，而re2dfa中的<code>\s</code>就不能。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/earley-introduction/" rel="prev" title="Earley算法和实现">
      <i class="fa fa-chevron-left"></i> Earley算法和实现
    </a></div>
      <div class="post-nav-item">
    <a href="/panic-in-wasm/" rel="next" title="在wasm中尝试从panic中恢复">
      在wasm中尝试从panic中恢复 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#过程宏"><span class="nav-number">1.</span> <span class="nav-text">过程宏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编写lexer"><span class="nav-number">1.1.</span> <span class="nav-text">编写lexer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#impl块的可选属性"><span class="nav-number">1.2.</span> <span class="nav-text">impl块的可选属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#产生式和语法动作"><span class="nav-number">1.3.</span> <span class="nav-text">产生式和语法动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个完整的例子"><span class="nav-number">1.4.</span> <span class="nav-text">一个完整的例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置文件"><span class="nav-number">2.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解决冲突"><span class="nav-number">3.</span> <span class="nav-text">解决冲突</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符集"><span class="nav-number">4.</span> <span class="nav-text">字符集</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MashPlant</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/MashPlant" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MashPlant" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MashPlant</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'X7kE28uGIr8V7x8FaNWY71aY-gzGzoHsz',
      appKey     : 'HdX9HsV0O0wHWAaEUurLSoTN',
      placeholder: "发表你的评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
